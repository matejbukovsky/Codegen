<?php declare(strict_types=1);

namespace Codegen;

use Codegen\Exceptions\CodegenOutputFolderException;
use Codegen\Templates\AbstractAnnotation;
use Codegen\Templates\AbstractTemplate;
use Doctrine\Common\Annotations\AnnotationReader;
use Nette\PhpGenerator\ClassType as GeneratorClassType;
use Nette\Reflection\ClassType;
use ReflectionException;
use Codegen\Annotations\Codegen as CodegenAnnotation;

class Codegen
{

	/**
	 * @var ColoredText
	 */
	private $coloredText;

	/**
	 * @var FileLoader
	 */
	private $fileLoader;

	/**
	 * @var AutoLoader
	 */
	private $autoloader;

	/**
	 * @var TemplateApplicator
	 */
	private $templateApplicator;

	/**
	 * @var FileWriter
	 */
	private $fileWriter;

	/**
	 * @var CliOptionsProvider
	 */
	private $config;

	public function __construct(
		FileLoader $fileLoader,
		FileWriter $fileWriter,
		TemplateApplicator $templateApplicator,
		AutoLoader $autoLoader,
		ColoredText $coloredText)
	{
		$this->fileLoader = $fileLoader;
		$this->fileWriter = $fileWriter;
		$this->templateApplicator = $templateApplicator;
		$this->autoloader = $autoLoader;
		$this->coloredText = $coloredText;
	}

	public function run(CliOptionsProvider $config): void
	{
		$this->config = $config;

		$loadedFiles = $this->autoloadFiles();
		$this->autoloader->addClasses($loadedFiles);
		$this->printStartInfo($loadedFiles);

		$annotationReader = new AnnotationReader();

		$done = 0;
		foreach ($loadedFiles as $realPath => $class) {
			$done++;
			if ($this->config->printProgressBar()) {
				$this->coloredText->progressBar($done, count($loadedFiles));
			}

			try {
				$classRef = new ClassType($class);
			} catch (ReflectionException $e) {
				$this->coloredText->printErrorString(sprintf('"%s". Skipping...', $e->getMessage()));
				continue;
			}

			$classAnnotation = $annotationReader->getClassAnnotation($classRef, CodegenAnnotation::class);
			if ($classAnnotation) {
				$classType = GeneratorClassType::withBodiesFrom($class);
				$classType->setComment("Class generated by Codegen. DO NOT EDIT !!!\n\n" . $classType->getComment());
				$classType = $this->templateApplicator->applyTemplates($classRef, $classType);
				$this->fileWriter->writeToFile($this->getFileContent($realPath, $classType), $classRef);
			} elseif ($this->config->copyWithoutAnnotation()) {
				$this->fileWriter->copyByReflection($classRef);
			}
		}

		if ($this->config->copyNonPHP()) {
			$this->copyNonPhpFiles();
		}
	}

	private function getFileContent(string $realPath, GeneratorClassType $classTypeGen): string
	{
		return $this->getClassHeader($realPath) . ((string) $classTypeGen);
	}

	private function getClassHeader(string $filePath): string
	{
		$header = '';
		$handle = fopen($filePath, "r");
		if ($handle) {
			while (($line = fgets($handle)) !== false) {
				if (
					strpos($line, 'class') !== 0 &&
					strpos($line, 'interface') !== 0 &&
					strpos($line, 'abstract') !== 0 &&
					strpos($line, 'final') !== 0 &&
					strpos($line, 'public') !== 0 &&
					strpos($line, '/**') !== 0) {
					$header .= $line;
				} else {
					break;
				}
			}

			fclose($handle);
		} else {
			$this->coloredText->printErrorString(sprintf('Cannot read file %s', $filePath));
		}

		return $header;
	}

	/**
	 * Prints app state before generating.
	 */
	private function printStartInfo(array $filteredFiles)
	{
		$this->coloredText->printKeyVal("Root dir:", $this->config->getRootDir());
		$this->coloredText->printKeyVal("Output dir:", $this->config->getOutputDir());
		$this->coloredText->printKeyVal("Accepted namespaces:", implode(' ,', $this->config->getAcceptedNamespaces()));
		$this->coloredText->printKeyVal("Excluded namespaces:", implode(' ,', $this->config->getExcludedNamespaces()));
		$this->coloredText->printKeyVal("Source paths:", implode(' ,', $this->config->getSourcePaths()));
		$this->coloredText->printKeyVal("Base namespace:", $this->config->getBaseNamespace());
		$templates = $this->fileLoader->getTemplateAnnotations($this->config->getTemplateDirs());

		$first = TRUE;
		foreach ($templates as $name => $path) {
			$key = '';
			if ($first) {
				$key = "Loaded templates:";
				$first = FALSE;
			}
			$this->coloredText->printKeyVal($key, sprintf("%-10s => %s", $name, $path));
		}
		$this->coloredText->printColoredString(sprintf("\n%s file%s found.\n", count($filteredFiles), count($filteredFiles) > 1 ? 's' : ''), 'brown');
	}

	/**
	 * @return string[]
	 */
	private function autoloadFiles(): array
	{
		$filesFromRoot = $this->fileLoader->getFilesWithNamespace($this->config->getRootDir(), $this->config->getOutputDir());
		$this->autoloader->addClasses($filesFromRoot);
		$filesFromPaths = $this->fileLoader->getFilesFromPaths($this->config->getSourcePaths());
		$this->autoloader->addClasses(array_flip($filesFromPaths));
		$filesByNamespace = $this->fileLoader->filterFilesByNamespace($filesFromRoot, $this->config->getAcceptedNamespaces(), $this->config->getExcludedNamespaces());
		$this->autoloader->addClasses($filesByNamespace);

		return array_merge($filesFromPaths, $filesByNamespace);
	}

	private function copyNonPhpFiles()
	{
		foreach ($this->config->getSourcePaths() as $sourcePath) {
			$files = $this->fileLoader->getFilesFromPath($sourcePath, '!php');
			foreach ($files as $file) {
				$this->fileWriter->copyFile($file, $sourcePath, $this->config->getOutputFolderToCopy());
			}
		}
	}

}
